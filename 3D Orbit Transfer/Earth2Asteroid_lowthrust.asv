addpath(genpath(pwd));

%% Initialize
AU = 1.49579151285e8;
mu_star = 1.32712440018e11; % [km3 / s2]
l_star = AU; % [km] one AU
m_star = 3000; % [kg] - max initial ship mass
a_star = mu_star / l_star ^ 2; % [km / s2]
t_star = sqrt(l_star ^ 3 / mu_star);
v_star = sqrt(mu_star/l_star);

year_to_sec = 86400.0 * 365.25;

u_max = 0.6; % [N]
mu = 1;
mu_dim = mu_star;
m0 = 3000 / m_star;
tf = 4.4 * year_to_sec / t_star;
N = 30;

%% Calculate max dV possible for continuous max thrust (ignoring external forces)
Isp = 4000; % [s]
g_0 = 9.80665; % [m / s2]
alpha = 1 / (Isp * g_0); % [s / m]

mf = m0 - alpha * u_max * tf * t_star / m_star;
dV_max = Isp * g_0 * log(m0 / mf) / 1000 / v_star;

%% Earth data
a_earth = 1.49579e8 / AU;
e_earth = 1.65519e-2;
inc_earth = 4.64389e-3;
Omega_earth = 1.98956e2;
omega_earth = 2.62960e2;
M_earth0 = deg2rad(3.58040e2);
M_earth = @(t) sqrt(mu / a_earth^3) * t + M_earth0;
E_earth = @(t) mean_to_eccentric_anomaly(M_earth(t), e_earth);
nu_earth = @(t) rad2deg(eccentric_to_true_anomaly(E_earth(t), e_earth));

%% Asteroid data
y=importdata('GTOC12_Asteroids_Data.txt');

[v, i] = max(y.data(:, 4))

AST = 42;%i; % Asteroid ID in range 1:60000

offset = 2;
a_ast = y.data(AST, offset + 1);
e_ast = y.data(AST, offset + 2);
inc_ast = y.data(AST, offset + 3);
Omega_ast = y.data(AST, offset + 4);
omega_ast = y.data(AST, offset + 5);
M_ast0 = deg2rad(y.data(AST, offset + 6));

M_ast = @(t) sqrt(mu / a_ast^3) * t + M_ast0;
E_ast = @(t) mean_to_eccentric_anomaly(M_ast(t), e_ast);
nu_ast = @(t) eccentric_to_true_anomaly(E_ast(t), e_ast);

%% Initial conditions
x_keplerian_earth = @(t) [a_earth e_earth inc_earth*pi/180 Omega_earth*pi/180 omega_earth*pi/180 M_earth(t)]';
x_cartesian_earth = @(t) keplerian_to_cartesian(x_keplerian_earth(t), [], mu);
x_keplerian_ast = @(t) [a_ast e_ast inc_ast*pi/180 Omega_ast*pi/180 omega_ast*pi/180 M_ast(t)]';
x_cartesian_ast = @(t) keplerian_to_cartesian(x_keplerian_ast(t), [], mu);

t_plot = linspace(0, tf, 100);
x_cartesian_earth_plot = zeros([6, numel(t_plot)]);
x_cartesian_ast_plot = zeros([6, numel(t_plot)]);
for k = 1:numel(t_plot)
    x_cartesian_earth_plot(:, k) = x_cartesian_earth(t_plot(k));
    x_cartesian_ast_plot(:, k) = x_cartesian_ast(t_plot(k));
end

x_earth0 = x_cartesian_earth(0);
r0 = x_earth0(1:3); v0 = x_earth0(4:6);
v_earth0 = x_earth0(4:6);
x_0 = [r0; v0; m0];
x_f = x_cartesian_ast(tf);

tspan = [0, tf];
t_k = linspace(tspan(1), tspan(2), N);
delta_t = t_k(2) - t_k(1);

u_hold = "ZOH";
Nu = (u_hold == "ZOH") * (N - 1) + (u_hold == "FOH") * N;

parser = "CVX";
nx = 7;
nu = 3;
np = 3;

initial_guess = "Lambert"; % "straight line" or "Lambert"

ptr_ops.iter_max = 30;
ptr_ops.iter_min = 2;
ptr_ops.Delta_min = 5e-4;
ptr_ops.w_vc = 1e2;
ptr_ops.w_tr = ones(1, Nu) * 5e-3;
ptr_ops.w_tr_p = 1e-4 * ones(1, np);
ptr_ops.update_w_tr = false;
ptr_ops.delta_tol = 6e-3;
ptr_ops.q = 2;
ptr_ops.alpha_x = 1;
ptr_ops.alpha_u = 1;
ptr_ops.alpha_p = 0;

scale = false;

f = @(t, x, u, p) dynamics(t, x, u);

max_thrust_constraint = {1:N, @(t, x, u, p) norm(u, 2) - u_max};
v_max_nd = 6 / v_star;
departure_velocity_constraint = {1, @(t, x, u, p) norm(p(1:3)) - v_max_nd};

convex_constraints = {max_thrust_constraint, departure_velocity_constraint};

initial_bc = @(x, p) [x(1:3) - x_0(1:3); x(4:6) - p(1:3) - x_0(4:6); x(7) - m0];
terminal_bc = @(x, p, x_ref, p_ref) [x(1:6) - x_f; 0];

if u_hold == "ZOH"
    min_fuel_objective = @(x, u, p, x_ref, u_ref, p_ref) sum(norms(u, 2, 1)) * delta_t;
else
    min_fuel_objective = @(x, u, p) sum((u(3, 1:(end - 1)) + u(3, 2:end)) / 2) * delta_t;
end

if initial_guess == "straight line"
    AU_guess = interp1(tspan, [a_earth, a_ast]', t_k);
    nu_guess = interp1(tspan, [nu_earth(0), nu_ast(tf)]', t_k);
    r_guess = [AU_guess .* cos(nu_guess); AU_guess .* sin(nu_guess)];
    r_guess(end + 1, :) = 0;
    v_guess = v_circ(r_guess, nu_guess, mu);
    v_guess(end + 1, :) = 0;
    m_guess = ones(1, N);
    
    guess.x = [r_guess; v_guess; m_guess];
    guess.u = interp1(tspan, ones(3, 2)' * 1e-5, t_k(1:Nu))';
    guess.p = [0; 0; 0];
elseif initial_guess == "Lambert"
    tofs = [tf];
    for i = 1 : numel(tofs)
        x_f_tofs(:, i) = x_cartesian_ast(tofs(i));
    end
    [v1_best, v2_best, dV_best, ToF_best, N_best] = best_lambert(repmat(x_0(1:6), 1, numel(tofs)), x_f_tofs, tofs, 3, 6 / v_star, 0);
    t_k_best = linspace(0, ToF_best, N);

    if dV_best > dV_max
        warning("WARNING: Lambert delta V %.1f%% greater than estimated max low thrust delta V", (dV_best - dV_max) / dV_max * 100)
    end

    guess = lambert_initial_guess(x_0(1:6), x_f_tofs(:, tofs == ToF_best), v1_best, v2_best, N_best, t_k_best, u_max, alpha, t_star, m_star, Isp, g_0, v_star, 6, 0, m0);
    guess.p = 6 / v_star * guess.u(:, 1) / norm(guess.u(:, 1));
end

problem = DeterministicProblem(x_0, x_f, N, u_hold, tf, f, guess, convex_constraints, min_fuel_objective, scale = scale, initial_bc = initial_bc, terminal_bc = terminal_bc, integration_tolerance = 1e-12, discretization_method = "error", N_sub = 1);

[problem, Delta_disc] = problem.discretize(guess.x, guess.u, guess.p);
ptr_sol = ptr(problem, ptr_ops, parser);

%%
if ~ptr_sol.converged
    ptr_sol.converged_i = ptr_ops.iter_max;
end

i = ptr_sol.converged_i + 1;
x = ptr_sol.x(:, :, i);
u = ptr_sol.u(:, :, i);
p = ptr_sol.p(:, i);
r = x(1:3, :); v = x(4:6, :);

x_0_opt = x_0 + [0; 0; 0; p(1:3); 0];

[t_cont_sol, x_cont_sol, u_cont_sol] = problem.cont_prop(ptr_sol.u(:, :, i), ptr_sol.p(:, i), x0 = x_0_opt);
r_cont_sol = x_cont_sol(1:3, :);
v_cont_sol = x_cont_sol(4:6, :);
%%
figure
plot_cartesian_orbit(r_cont_sol(1:3,:)', 'k', 0.4, 1); hold on
quiver3(r(1, 1:Nu), r(2, 1:Nu), r(3, 1:Nu), u(1, :), u(2, :), u(3, :), 1, "filled", Color = "red")
quiver3(r(1, 1), r(2, 1), r(3, 1), p(1), p(2), p(3), 2, "filled", Color = "magenta", LineWidth=1, MaxHeadSize=1)
plot_cartesian_orbit(r_guess(1:3,:)', 'g', 0.4, 1); hold on
plot_cartesian_orbit(x_cartesian_earth_plot(1:3, :)', 'b', 0.3, 1)
plot_cartesian_orbit(x_cartesian_ast_plot(1:3, :)', 'cyan', 0.3, 1)
scatter3(x_cartesian_earth_plot(1, 1), x_cartesian_earth_plot(2, 1), x_cartesian_earth_plot(3, 1), "green")
scatter3(x_cartesian_ast_plot(1, end), x_cartesian_ast_plot(2, end), x_cartesian_ast_plot(3, end), "red")
title('Optimal Transfer Trajectory')
xlabel('x (AU)'); ylabel('y (AU)')
legend('Spacecraft', "", "Thrust", "Launch Velocity", 'Guess', "", 'Earth', "", 'Asteroid', "", "Start", "End", 'Location', 'northwest'); axis equal; grid on

%%
figure
tiledlayout(1, 2)

nexttile
plot(t_cont_sol(1:end - 1), u_cont_sol(1:3,:), LineWidth=1); hold on
plot(t_cont_sol(1:end - 1), vecnorm(u_cont_sol(1:3,:)), LineWidth=1)
title("Control")
xlabel("Time")

nexttile
plot(t_cont_sol(1:end), x_cont_sol(7, :))
title("Mass")
xlabel("Time")

%% Compare dV used with rocket equation estimate
dV_cont = sum(vecnorm(u_cont_sol) ./ (x_cont_sol(7, 1 : (end - 1)) * m_star) .* diff(t_cont_sol)' * t_star / 1000 / v_star); % delta V

dV_rocket_equation = Isp * g_0 * log(x_0(7) / x(7, end)) / 1000 / v_star;

rel_dV_error_perc_rocket_equation = (dV_cont - dV_rocket_equation) / dV_cont * 100

%% Helper
function [v_guess] = v_circ(r_guess, nu_guess, mu)
    r = vecnorm(r_guess, 2, 1);
    v = sqrt(mu ./ r);
    v_guess = v .* [-sin(nu_guess); cos(nu_guess)];
end


function [v1_best, v2_best, dV_best, ToF_best, N_best] = best_lambert(x_1, x_2, ToF, N_max, v1_assist, v2_assist)
    % if ToF is an array, will pick lowest dV

    %enter path of the the dll directory with all required files including .bin (with slash at end) 
    dllDirectory_Path = convertStringsToChars(string(cd) + "\LambertSolvers\ivLamV2p41_738416p65617\matlabInterface\lib\");  %at distribution in this file near the driver, otherwise change here.
    
    addpath(dllDirectory_Path) %add the path where the .dll resides

    %load the dll and initialize the lambert routines
    iflag=ivLam_initializeDLL(dllDirectory_Path);
    if(iflag~=0)
        return
    else
        disp('coef path and dll path appear correct, data loaded ok!')
    end

    % Solve Lambertus Maximus
    Q = numel(ToF) * 2;
    r1vec = repmat(x_1(1:3), 1, Q);
    r2vec = repmat(x_2(1:3), 1, Q);
    direction = [ones([Q, 1]); -ones(Q, 1)];


    [v1vec,v2vec,uptoNhave,infoReturnStatus,infoHalfRevStatus] = ivLam_thruN_multipleInputDLL(Q, r1vec, r2vec, repmat(ToF, 2, 1), direction, N_max);

    %in order to retrieve solutions, we need the Ni2col() function to get the correct column
            
    % Retrieve solutions
    [Ns, Qs] = meshgrid(0 : N_max, 1 : Q);
    jcolumn = Ni2col(Ns, Qs, N_max);

    % Filter out NaN and 0 solutions
    vel1_unfiltered = v1vec(1:3,jcolumn(:));
    vel2_unfiltered = v2vec(1:3,jcolumn(:));

    v_filter = all(~isnan(vel1_unfiltered), 1) & any(vel1_unfiltered ~= 0, 1) ...
               & all(~isnan(vel2_unfiltered), 1) & any(vel2_unfiltered ~= 0, 1);

    vel1 = vel1_unfiltered(:, v_filter);
    vel2 = vel2_unfiltered(:, v_filter);

    % Calculate delta V
    v1_b = repmat(x_1(4:6, :), 1, 2 * (N_max + 1));
    v2_b = repmat(x_2(4:6, :), 1, 2 * (N_max + 1));
    dV = max(vecnorm(v1_b(:, v_filter) - vel1) - v1_assist, 0) + max(vecnorm(v2_b(:, v_filter) - vel2) - v2_assist, 0);

    % Extract best solution
    [dV_best, q_best_filtered] = min(dV);
    v1_best = vel1(:, q_best_filtered);
    v2_best = vel2(:, q_best_filtered);

    filter_indices = find(v_filter);
    q_best = mod(filter_indices(q_best_filtered) - 1, Q) + 1;

    N_best = ceil(filter_indices(q_best_filtered) / Q) - 1;

    ToF_best = ToF(q_best);

    % Package outputs
    % v1_best, v2_best, dV_best, ToF_best, N_best

    %unload the dll and clear memory from the lambert routines
    iflag= ivLam_unloadDataDLL();
end

function [guess] = lambert_initial_guess(x_1, x_2, v_1_trans, v_2_trans, N_rev, t_k, u_max, alpha, t_star, m_star, Isp, g_0, v_star, v_1_assist, v_2_assist, m_0)
    % Construct initial guess from lambert solution
    
    x_1_trans = [x_1(1:3); v_1_trans];
    x_2_trans = [x_2(1:3); v_2_trans];

    % Construct transfer orbit
    [x_1_trans_keplerian, thetastar_1_trans] = cartesian_to_keplerian(x_1_trans, [0; 0; 1], [1; 0; 0], 1);
    [x_2_trans_keplerian, thetastar_2_trans] = cartesian_to_keplerian(x_2_trans, [0; 0; 1], [1; 0; 0], 1);

    thetastar_trans = linspace(thetastar_1_trans, thetastar_2_trans + N_rev * 2 * pi, numel(t_k));

    transfer_cartesian = keplerian_to_cartesian_array(repmat(x_1_trans_keplerian, 1, numel(t_k))', thetastar_trans, 1)';

    %plot3(transfer_cartesian(1, :), transfer_cartesian(2, :), transfer_cartesian(3, :))

    % Approximate controls
    u_guess = zeros([3, numel(t_k) - 1]); % assume ZOH

    % Assume constant max thrust in dV direction until dV reached
    % Use Tsiolovsky rocket equation
    dV_1_dir = v_1_trans - x_1(4:6);
    dV_1_mag = norm(dV_1_dir);    

    % Propagate forward from beginning to estimate mass and control for
    % departing
    m_guess = zeros([1, numel(t_k)]);
    m_guess(1) = m_0;
    dV_1_left = dV_1_mag - v_1_assist / v_star;
    for k = 1 : (numel(t_k) - 1)
        m_guess(k + 1) = m_guess(k) - alpha * u_max * (t_k(k + 1) - t_k(k)) * t_star / m_star;
        dV_1_left = dV_1_left - Isp * g_0 * log(m_guess(k) / m_guess(k + 1)) / 1000 / v_star;

        u_guess(:, k) = u_max * dV_1_dir;

        if dV_1_left < 0
            m_guess((k + 1) : end) = m_guess(k);
            break;
        end
    end

    dV_2_dir = x_2(4:6) - v_2_trans;
    dV_2_mag = norm(dV_2_dir);    

    mf_expected = exp(dV)

    % Propagate backward from ending to estimate mass and control for
    % arriving
    dV_2_done = dV_2_mag - v_2_assist / v_star;
    for k = (numel(t_k) - 1) : -1 : 2
        delta_m = alpha * u_max * (t_k(k) - t_k(k - 1)) * t_star / m_star;

        if m_guess(k) + delta_m < m_guess(k - 1)
            m_guess(k - 1) = m_guess(k) + delta_m;
            dV_2_done = dV_2_done + Isp * g_0 * log(m_guess(k - 1) / m_guess(k)) / 1000 / v_star;
    
            u_guess(:, k) = u_max * dV_2_dir;
        else
            break;
        end

        if dV_2_done < 0
            break;
        end
    end

    % Package guess
    guess.x = [transfer_cartesian; m_guess];
    guess.u = u_guess;
end